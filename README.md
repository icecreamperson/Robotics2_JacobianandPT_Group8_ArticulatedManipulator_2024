# Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024
![1](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/79f6cf39-1254-43da-9b8b-19182c8d54f2)
![2](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/82f6e5e7-b38c-42c5-bc37-990e5ade2633)
![3](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/93983368-8035-4e90-b6ab-bd541f46ab16)

**LINK FOR TASK 1:**
https://drive.google.com/file/d/131KqPXrkv2D0oQX0m2TL3AIkOpvIrm_u/view?usp=drive_link

**LINK FOR TASK 2:**
https://drive.google.com/file/d/1VBuQTJ9nbtTNi2ZxQbCpKRM8b81p4c8o/view?usp=drive_link

**LINK FOR TASK 3:**
https://drive.google.com/file/d/1__Y3kae4J-FsyOtdiPTm46toSXVrdJAe/view?usp=drive_link

**LINK FOR TASK 4:**
https://drive.google.com/file/d/136p0FQQEMhvFcT6H3m3JVeorJDbAsUvk/view?usp=drive_link

**LINK FOR TASK 5:**
https://drive.google.com/file/d/1RvCZi8VDp7HcbdiaaJg9v4KS0fdVEMjE/view?usp=drive_link

![4](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/7c4d7206-198e-45d2-94f2-3c6790923b80)
![5](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/d89fb2bc-0983-466e-91ce-d83258970132)
![6](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/a5d57806-a9a1-4003-a32d-e8477acd238a)
![7](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/2c6f0a96-a0ff-44a8-8361-d9d8de20af5b)
![8](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/9a01c777-6db1-4ab9-b085-efbc245e5a99)
![9](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/2491b116-2638-4a44-b558-77feb3e789ea)
![10](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/595d2886-0d62-4177-bd45-6675b2c8e317)
![11](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/83acc54a-b3db-47fb-a1be-340a62ed1593)
![13](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/a8fe3021-9ad7-454e-a756-92a9a9b180f7)
![14](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/18dd7f44-5bba-488d-ac2a-489ca51e9f82)
![15](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/9be6e76c-3ecc-46d4-9ccc-878cefbb1ffb)
![16](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/2b3378e3-eda5-4b9e-8952-c4066ce386d8)
![17](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/d7ac14cc-d1f5-4324-ac24-2986755f67b5)
![18](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/3522a97b-ecab-49ba-a1c4-80392d3f6bfe)
![JACOBIAN MATRIX AND TRAJECTORY PLANNING_ROBOTICS 2 FINAL PROJECT](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/9e020c9e-1b86-4441-ab66-0826e9025288)
![27](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/1ee2de74-04bb-4699-835c-13b22fd4fbda)
![28](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/4b3f7086-c028-44bc-bd94-45d51bb3efd6)
![29](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/835b4078-cb3c-4c27-adc9-311157640a44)
![19](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/7fe2e549-34b1-49b6-98fb-77aceaceaa56)
![20](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/5f1e7272-14e3-4281-80bd-c65f19efe711)
![21](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/8dd77c02-b61a-4704-b4d9-85636f2ef06c)
import numpy as np
import math
import roboticstoolbox as rtb
from roboticstoolbox import DHRobot, RevoluteDH
import spatialmath
from spatialmath import SE3
import matplotlib

a1 = float(input("a1 = "))*100
a2 = float(input("a2 = "))*100
a3 = float(input("a3 = "))*100

def mm_m(a):
    m = 100 #; meter = 1000mm
    return a/m

a1 = mm_m(a1)
a2 = mm_m(a2)
a3 = mm_m(a3)


# Create links
#robot variable =  DHrobot([RevoluteDH,(d,r,alpha,offset,qlim)])
#robot variable =  DHrobot([PrismaticDH,(d=0,r,alpha,offset=d,qlim)])

Articulated = DHRobot([
    RevoluteDH(a1,0,(90.0/180.0)*np.pi,(0.0/180.0)*np.pi,qlim=[-np.pi/2,np.pi/2]),
    RevoluteDH(0,a2,(0.0/180.0)*np.pi,(0.0/180.0)*np.pi,qlim=[-np.pi/2,np.pi/2]),
    RevoluteDH(0,a3,(0.0/180.0)*np.pi,(0.0/180.0)*np.pi,qlim=[-np.pi/2,np.pi/2])
],name='Articulated')

print(Articulated)

## Path and Trajectory Planning

# degrees to radian converter
def deg_to_rad(T):
    return (T/180.0)*np.pi

## q Planned Paths
# for Cylindrical Jonit Variables = ([T1,d2,d3])

q0 = np.array([0,0,0])

q1 = np.array([deg_to_rad(0),
                deg_to_rad(-30),
                deg_to_rad(-30)])  #pick1

q2 = np.array([deg_to_rad(0),
                deg_to_rad(0),
                deg_to_rad(0)])  #return1

q3 = np.array([deg_to_rad(90),
                deg_to_rad(0),
                deg_to_rad(0)])  #revolve1

q4 = np.array([deg_to_rad(90),
                deg_to_rad(-30),
                deg_to_rad(-30)])  #place1


q5 = np.array([deg_to_rad(90),
                deg_to_rad(0),
                deg_to_rad(0)]) #return 2

q6 = np.array([deg_to_rad(180),
                deg_to_rad(0),
                deg_to_rad(0)]) #revolve2

q7 = np.array([deg_to_rad(180),
                deg_to_rad(-30),
                deg_to_rad(-30)]) #pick 3

q8 = np.array([deg_to_rad(180),
                deg_to_rad(0),
                deg_to_rad(0)]) #return3

q9 = np.array([deg_to_rad(270),
                deg_to_rad(0),
                deg_to_rad(0)]) #revolve3

q10 = np.array([deg_to_rad(270),
                deg_to_rad(-30),
                deg_to_rad(-30)]) #place3

q11 = np.array([deg_to_rad(270),
                 deg_to_rad(0),
                 deg_to_rad(0)]) #return4

q12 = np.array([deg_to_rad(360),
                deg_to_rad(0),
                deg_to_rad(0)]) #revolve4

q13 = np.array([deg_to_rad(360),
                deg_to_rad(-30),
                deg_to_rad(-30)]) # place 4 


# planned Trajectories
traj1 = rtb.jtraj(q0,q1,20)
traj2 = rtb.jtraj(q1,q2,20)
traj3 = rtb.jtraj(q2,q3,20)
traj4 = rtb.jtraj(q3,q4,20)
traj5 = rtb.jtraj(q4,q5,20)
traj6 = rtb.jtraj(q5,q6,20)
traj7 = rtb.jtraj(q6,q7,20)
traj8 = rtb.jtraj(q7,q8,20)
traj9 = rtb.jtraj(q8,q9,20)
traj10 = rtb.jtraj(q9,q10,20)
traj11 = rtb.jtraj(q10,q11,20)
traj12 = rtb.jtraj(q11,q12,20)
traj13 = rtb.jtraj(q12,q13,20)
traj14 = rtb.jtraj(q13,q0,20)

#plot scale
x1 = -50
x2 = 50
y1 = -50
y2 = 50
z1 = 0
z2 = 50

# Path and Trajectory plotting
Articulated.plot(traj1.q,limits=[x1, x2, y1, y2, z1, z2])
Articulated.plot(traj2.q,limits=[x1, x2, y1, y2, z1, z2])
Articulated.plot(traj3.q,limits=[x1, x2, y1, y2, z1, z2])
Articulated.plot(traj4.q,limits=[x1, x2, y1, y2, z1, z2])
Articulated.plot(traj5.q,limits=[x1, x2, y1, y2, z1, z2])
Articulated.plot(traj6.q,limits=[x1, x2, y1, y2, z1, z2])
Articulated.plot(traj7.q,limits=[x1, x2, y1, y2, z1, z2])
Articulated.plot(traj8.q,limits=[x1, x2, y1, y2, z1, z2])
Articulated.plot(traj9.q,limits=[x1, x2, y1, y2, z1, z2])
Articulated.plot(traj10.q,limits=[x1, x2, y1, y2, z1, z2])
Articulated.plot(traj11.q,limits=[x1, x2, y1, y2, z1, z2])
Articulated.plot(traj12.q,limits=[x1, x2, y1, y2, z1, z2])
Articulated.plot(traj13.q,limits=[x1, x2, y1, y2, z1, z2])
Articulated.plot(traj14.q,limits=[x1, x2, y1, y2, z1, z2],block=True)
![22](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/cd5f6eb0-a8c9-4081-bdde-18be44d120f3)
from tkinter import *
from tkinter import messagebox
from tkinter import PhotoImage
from tkinter import font
import numpy as np
import roboticstoolbox as rtb
from roboticstoolbox import DHRobot, RevoluteDH, PrismaticDH
from PIL import Image
from PIL import Image, ImageTk
import matplotlib
matplotlib.use('TkAgg')


gui =  Tk()
gui.title("ARTICULATED Design Calculator")
gui.resizable(False,False)
gui.config(bg="grey")

new_font = font.Font(family="Times New Roman", size=15, weight="bold")

def reset():
    a1_E.delete(0, END)
    a2_E.delete(0, END)
    a3_E.delete(0, END)

    T1_E.delete(0, END)
    T2_E.delete(0, END)
    T3_E.delete(0, END)

    X_E.delete(0, END)
    Y_E.delete(0, END)
    Z_E.delete(0, END)

def f_k():

    a1 = float(a1_E.get())
    a2 = float(a2_E.get())
    a3 = float(a3_E.get())
    
    def mm_to_meter(a):
        m = 1000
        return a/m

    a1 = mm_to_meter(a1)
    a2 = mm_to_meter(a2) 
    a3 = mm_to_meter(a3)  

    T1 = float(T1_E.get()) 
    T2 = float(T2_E.get()) 
    T3 = float(T3_E.get()) 

    T1 = (T1/180.0)*np.pi
    T2 = (T2/180.0)*np.pi
    T3 = (T3/180.0)*np.pi

    PT = [[T1,(90.0/180.0)*np.pi,0,a1],
        [T2,(0.0/180.0)*np.pi,a2,0],
        [T3,(0.0/180.0)*np.pi,a3,0]]

    i = 0
    H0_1 = [[np.cos(PT[i][0]),-np.sin(PT[i][0])*np.cos(PT[i][1]),np.sin(PT[i][0])*np.sin(PT[i][1]),PT[i][2]*np.cos(PT[i][0])],
            [np.sin(PT[i][0]),np.cos(PT[i][0])*np.cos(PT[i][1]),-np.cos(PT[i][0])*np.sin(PT[i][1]),PT[i][2]*np.sin(PT[i][0])],
            [0,np.sin(PT[i][1]),np.cos(PT[i][1]),PT[i][3]],
            [0,0,0,1]]

    i = 1
    H1_2 = [[np.cos(PT[i][0]),-np.sin(PT[i][0])*np.cos(PT[i][1]),np.sin(PT[i][0])*np.sin(PT[i][1]),PT[i][2]*np.cos(PT[i][0])],
            [np.sin(PT[i][0]),np.cos(PT[i][0])*np.cos(PT[i][1]),-np.cos(PT[i][0])*np.sin(PT[i][1]),PT[i][2]*np.sin(PT[i][0])],
            [0,np.sin(PT[i][1]),np.cos(PT[i][1]),PT[i][3]],
            [0,0,0,1]]

    i = 2
    H2_3 = [[np.cos(PT[i][0]),-np.sin(PT[i][0])*np.cos(PT[i][1]),np.sin(PT[i][0])*np.sin(PT[i][1]),PT[i][2]*np.cos(PT[i][0])],
            [np.sin(PT[i][0]),np.cos(PT[i][0])*np.cos(PT[i][1]),-np.cos(PT[i][0])*np.sin(PT[i][1]),PT[i][2]*np.sin(PT[i][0])],
            [0,np.sin(PT[i][1]),np.cos(PT[i][1]),PT[i][3]],
            [0,0,0,1]]
    
    H0_1= np.matrix(H0_1)
    H1_2= np.matrix(H1_2)
    H2_3= np.matrix(H2_3)

    H0_2 = np.dot(H0_1,H1_2)
    H0_3 = np.dot(H0_2,H2_3)

    X0_3 = H0_3[0,3]
    X_E.delete(0,END)
    X_E.insert(0,np.around(X0_3,3))
    Y0_3 = H0_3[1,3]
    Y_E.delete(0,END)
    Y_E.insert(0,np.around(Y0_3,3))
    Z0_3 = H0_3[2,3]
    Z_E.delete(0,END)
    Z_E.insert(0,np.around(Z0_3,3))

    J_sw = Toplevel()
    J_sw.title('Velocity Calculator')
    J_sw.resizable(False,False)

        #1. Linear/Prismatic Vectors
    Z_1 = [[0],
            [0],
            [1]] # The [0,0,1] vector
        
        #Row 1 to 3, Column 1
    J1a = [[1,0,0],
            [0,1,0],
            [0,0,1]] #R0_0
    J1a = np.dot(J1a,Z_1)

    J1b_1 = H0_3[0:3,3]
    J1b_1 = np.matrix (J1b_1)

    J1b_2 = [[0],[0],[0]]
    J1b_2 = np.matrix (J1b_2)

    J1b = J1b_1 - J1b_2

    J1 = [[(J1a[1,0]*J1b[2,0])-(J1a[2,0]*J1b[1,0])],
            [(J1a[2,0]*J1b[0,0])-(J1a[0,0]*J1b[2,0])],
            [(J1a[0,0]*J1b[1,0])-(J1a[1,0]*J1b[0,0])]]
    
    J1 = np.matrix(J1)

    #Row 1 to 3, Column 2
    J2a = H0_1[0:3,0:3] #R0_1
    J2a = np.dot (J2a,Z_1)

    J2b_1 = H0_3[0:3,3]
    J2b_1 = np.matrix (J2b_1)

    J2b_2 = H0_1[0:3,3]
    J2b_2 = np.matrix (J2b_2)

    J2b = J2b_1 - J2b_2

    J2 = [[(J2a[1,0]*J2b[2,0])-(J2a[2,0]*J2b[1,0])],
        [(J2a[2,0]*J2b[0,0])-(J2a[0,0]*J2b[2,0])],
        [(J2a[0,0]*J2b[1,0])-(J2a[1,0]*J2b[0,0])]]
    
    J2 = np.matrix(J2)

    #Row 1 to 3, Column 3
    J3a = H0_2[0:3,0:3]
    J3a = np.dot (J3a,Z_1)

    J3b_1 = H0_3[0:3,3:]
    J3b_1 = np.matrix (J3b_1)

    J3b_2 = H0_2[0:3,3:]
    J3b_2 = np.matrix (J3b_2)

    J3b = J3b_1 - J3b_2

    J3 = [[(J3a[1,0]*J3b[2,0])-(J3a[2,0]*J3b[1,0])],
        [(J3a[2,0]*J3b[0,0])-(J3a[0,0]*J3b[2,0])],
        [(J3a[0,0]*J3b[1,0])-(J3a[1,0]*J3b[0,0])]]
    
    J3 = np.matrix(J3)

    #2. Rotation/Orientation Vectors

    #Row 4 to 6, Column 1
    J4 = J1a
    J4 = np.matrix(J4)

    #Row 4 to 6, Column 2
    J5 = J2a
    J5 = np.matrix(J5)

    #Row 4 to 6, Column 3
    J6 = J3a
    J6 = np.matrix(J6)

    #3. Concatenated Jacobian Matrix
    JM1 = np.concatenate((J1,J2,J3),1)
    JM2 = np.concatenate((J4,J5,J6),1)

    J = np.concatenate((JM1,JM2),0)
    J = np.matrix(J)

        #Velocity Slide Update
    def upd_velo():
            T1p = T1_slider.get()
            T2p = T2_slider.get()
            T3p = T3_slider.get()

            q = np.array([[T1p],[T2p],[T3p]])
            E = np.dot(J,q)

            xp_e = E[0,0]
            x_entry.delete(0,END)
            x_entry.insert(0,str(xp_e))
            
            yp_e = E[1,0]
            y_entry.delete(0,END)
            y_entry.insert(0,str(yp_e))

            zp_e = E[2,0]
            z_entry.delete(0,END)
            z_entry.insert(0,str(zp_e))

            ωx_e = E[3,0]
            ωx_entry.delete(0,END)
            ωx_entry.insert(0,str(ωx_e))

            ωy_e = E[4,0]
            ωy_entry.delete(0,END)
            ωy_entry.insert(0,str(ωy_e))

            ωz_e = E[5,0]
            ωz_entry.delete(0,END)
            ωz_entry.insert(0,str(ωz_e))

        #Jacobian Sliders
    T1_velo = Label(J_sw,text=('θ1* ='),font=(5))
    T1_slider = Scale(J_sw,from_=0,to_=3.142,orient=HORIZONTAL,length=100,sliderlength=10)
    T1_unit = Label(J_sw,text=('rad/s'),font=(5))

    T2_velo = Label(J_sw,text=('θ2* ='),font=(5))
    T2_slider = Scale(J_sw,from_=0,to_=3.142,orient=HORIZONTAL,length=100,sliderlength=10)
    T2_unit = Label(J_sw,text=('rad/s'),font=(5))

    T3_velo = Label(J_sw,text=('θ3* ='),font=(5))
    T3_slider = Scale(J_sw,from_=0,to_=3.142,orient=HORIZONTAL,length=100,sliderlength=10)
    T3_unit = Label(J_sw,text=('rad/s'),font=(5))

    T1_velo.grid(row=0,column=0)
    T1_slider.grid(row=0,column=1)
    T1_unit.grid(row=0,column=2)

    T2_velo.grid(row=1,column=0)
    T2_slider.grid(row=1,column=1)
    T2_unit.grid(row=1,column=2)

    T3_velo.grid(row=2,column=0)
    T3_slider.grid(row=2,column=1)
    T3_unit.grid(row=2,column=2)

    #Jacobian Entries and Labels
    x_velo = Label(J_sw,text=('x* ='),font=(5))
    x_entry = Entry(J_sw,width=10,font=(10))
    x_unit = Label(J_sw,text=('cm/s'),font=(5))
    x_velo.grid(row=3,column=0)
    x_entry.grid(row=3,column=1)
    x_unit.grid(row=3,column=2)

    y_velo = Label(J_sw,text=('y* ='),font=(5))
    y_entry = Entry(J_sw,width=10,font=(10))
    y_unit = Label(J_sw,text=('cm/s'),font=(5))
    y_velo.grid(row=4,column=0)
    y_entry.grid(row=4,column=1)
    y_unit.grid(row=4,column=2)

    z_velo = Label(J_sw,text=('z* ='),font=(5))
    z_entry = Entry(J_sw,width=10,font=(10))
    z_unit = Label(J_sw,text=('cm/s'),font=(5))
    z_velo.grid(row=5,column=0)
    z_entry.grid(row=5,column=1)
    z_unit.grid(row=5,column=2)

    ωx_velo = Label(J_sw,text=('ωx ='),font=(5))
    ωx_entry = Entry(J_sw,width=10,font=(10))
    ωx_unit = Label(J_sw,text=('rad/s'),font=(5))
    ωx_velo.grid(row=6,column=0)
    ωx_entry.grid(row=6,column=1)
    ωx_unit.grid(row=6,column=2)

    ωy_velo = Label(J_sw,text=('ωy ='),font=(5))
    ωy_entry = Entry(J_sw,width=10,font=(10))
    ωy_unit = Label(J_sw,text=('rad/s'),font=(5))
    ωy_velo.grid(row=7,column=0)
    ωy_entry.grid(row=7,column=1)
    ωy_unit.grid(row=7,column=2)

    ωz_velo = Label(J_sw,text=('ωz ='),font=(5))
    ωz_entry = Entry(J_sw,width=10,font=(10))
    ωz_unit = Label(J_sw,text=('rad/s'),font=(5))
    ωz_velo.grid(row=8,column=0)
    ωz_entry.grid(row=8,column=1)
    ωz_unit.grid(row=8,column=2)

    #Update Button
    update = Button(J_sw,text='Update',bg='green',fg='white',command=upd_velo)
    update.grid(row=9,column=0)

    ARTICULATED = DHRobot([
        RevoluteDH(a1,0,(90.0/180.0)*np.pi,(0.0/180.0)*np.pi,qlim=[-np.pi/2,np.pi/2]),
        RevoluteDH(0,a2,(0.0/180.0)*np.pi,(0.0/180.0)*np.pi,qlim=[-np.pi/2,np.pi/2]),
        RevoluteDH(0,a3,(0.0/180.0)*np.pi,(0.0/180.0)*np.pi,qlim=[-np.pi/2,np.pi/2])
        ], name="ARTICULATED")
    
    q1 = np.array([T1,T2,T3])


    x1 = -0.5
    x2 = 0.5
    y1 = -0.5
    y2 = 0.5
    z1 = 0.0
    z2 = 0.5     

    # Plot commands
    ARTICULATED.plot(q1,limits=[x1,x2,y1,y2,z1,z2],block=True) 



def i_k():
    a1 = float(a1_E.get())
    a2 = float(a2_E.get())
    a3 = float(a3_E.get())

    def mm_to_meter(a):
        m = 1000
        return a/m

    a1 = mm_to_meter(a1)
    a2 = mm_to_meter(a2) 
    a3 = mm_to_meter(a3)  

    xe = float(X_E.get())
    ye = float(Y_E.get())
    ze = float(Z_E.get())

    if xe == 0:
        Th1 = (np.pi/2) * 180/np.pi if ye > 0 else (-np.pi/2) * 180/np.pi
    else:
        Th1 = np.arctan(ye/xe) * 180/np.pi #1

    r1 = np.sqrt(ye**2 + xe**2) #2
    r2 = ze - a1 #3

    if r1 == 0:
        phi1 = np.pi/2 if r2 > 0 else - np.pi/2
    else:
        phi1 = np.arctan(r2/r1) #4
    r3 = np.sqrt(r2**2 + r1**2) #5

    phi2 = np.arccos(np.clip((a3**2-a2**2-r3**2)/(-2*a2*r3),-1,1)) #6

    Th2 = (phi1 + phi2) * 180/np.pi #7

    phi3 =  phi3 = np.arccos(np.clip((r3**2-a2**2-a3**2)/(-2*a2*a3),-1,1)) #8

    Th3 = (phi3-np.pi) * 180/np.pi #9


    T1_E.delete(0,END)
    T1_E.insert(0,np.around(Th1,3))

    T2_E.delete(0,END)
    T2_E.insert(0,np.around(Th2,3))

    T3_E.delete(0,END)
    T3_E.insert(0,np.around(Th3,3))

    ARTICULATED = DHRobot([
        RevoluteDH(a1,0,(90.0/180.0)*np.pi,(0.0/180.0)*np.pi,qlim=[-np.pi/2,np.pi/2]),
        RevoluteDH(0,a2,(0.0/180.0)*np.pi,(0.0/180.0)*np.pi,qlim=[-np.pi/2,np.pi/2]),
        RevoluteDH(0,a3,(0.0/180.0)*np.pi,(0.0/180.0)*np.pi,qlim=[-np.pi/2,np.pi/2])
        ], name="ARTICULATED")
    
    q1 = np.array([Th1,Th2,Th3])


    x1 = -0.5
    x2 = 0.5
    y1 = -0.5
    y2 = 0.5
    z1 = 0.0
    z2 = 0.5   
    
    print(ARTICULATED)
    ARTICULATED.plot(q1,limits=[x1,x2,y1,y2,z1,z2],block=True) 

def pt():
    a1 = float(a1_E.get())
    a2 = float(a2_E.get())
    a3 = float(a3_E.get())

    def mm_m(a):
        m = 100 #; meter = 1000mm
        return a/m

    a1 = mm_m(a1)
    a2 = mm_m(a2)
    a3 = mm_m(a3)


    # Create links
    #robot variable =  DHrobot([RevoluteDH,(d,r,alpha,offset,qlim)])
    #robot variable =  DHrobot([PrismaticDH,(d=0,r,alpha,offset=d,qlim)])

    Articulated = DHRobot([
        RevoluteDH(a1,0,(90.0/180.0)*np.pi,(0.0/180.0)*np.pi,qlim=[-np.pi/2,np.pi/2]),
        RevoluteDH(0,a2,(0.0/180.0)*np.pi,(0.0/180.0)*np.pi,qlim=[-np.pi/2,np.pi/2]),
        RevoluteDH(0,a3,(0.0/180.0)*np.pi,(0.0/180.0)*np.pi,qlim=[-np.pi/2,np.pi/2])
    ],name='Articulated')

    print(Articulated)

    ## Path and Trajectory Planning
    # q paths
    # Articulated Joint Variables = ([T1, T2, T3])
    # degrees to radian

    def deg_to_rad(T):
        return (T/180.0)*np.pi

    ## q Planned Paths
    # for Articulated Jonit Variables = ([T1,T2,T3])

    q0 = np.array([0,0,0]) #starting position

    q1 = np.array([deg_to_rad(0),
                    deg_to_rad(-30),
                    deg_to_rad(-30)])  #pick position1

    q2 = np.array([deg_to_rad(90),
                    deg_to_rad(0),
                    deg_to_rad(0)])  #revolve 90 degrees

    q3 = np.array([deg_to_rad(90),
                    deg_to_rad(-30),
                    deg_to_rad(-30)])  #place position1

    q4 = np.array([deg_to_rad(180),
                    deg_to_rad(0),
                    deg_to_rad(0)]) #revolve 180 degrees

    q5 = np.array([deg_to_rad(180),
                    deg_to_rad(-30),
                    deg_to_rad(-30)]) #place position2

    q6 = np.array([deg_to_rad(270),
                    deg_to_rad(0),
                    deg_to_rad(0)]) #revolve 270 degrees

    q7 = np.array([deg_to_rad(270),
                    deg_to_rad(-30),
                    deg_to_rad(-30)]) #place position3

    q8 = np.array([deg_to_rad(360),
                    deg_to_rad(0),
                    deg_to_rad(0)]) #end position

    steps = 20
    # planned Trajectories
    traj1 = rtb.jtraj(q0,q1,steps) # pick 1 start
    traj2 = rtb.jtraj(q1,q0,steps) # up 1
    traj3 = rtb.jtraj(q0,q2,steps) # rotate 1
    traj4 = rtb.jtraj(q2,q3,steps) # place 1
    traj5 = rtb.jtraj(q3,q2,steps) # retract 1
    traj6 = rtb.jtraj(q2,q0,steps) # return 1
    traj7 = rtb.jtraj(q0,q1,steps) # pick 2
    traj8 = rtb.jtraj(q1,q0,steps) # up 2
    traj9 = rtb.jtraj(q0,q4,steps) # rotate 2
    traj10 = rtb.jtraj(q4,q5,steps) # place 2
    traj11 = rtb.jtraj(q5,q4,steps) # retract 2
    traj12 = rtb.jtraj(q4,q0,steps) # return 2
    traj13 = rtb.jtraj(q0,q1,steps) # pick 3
    traj14 = rtb.jtraj(q1,q0,steps) # up 3
    traj15 = rtb.jtraj(q0,q6,steps) # rotate 3
    traj16 = rtb.jtraj(q6,q7,steps) # place 3
    traj17 = rtb.jtraj(q7,q6,steps) # retract 3
    traj18 = rtb.jtraj(q6,q8,steps) # return 3 end

    #plot scale
    x1 = -50
    x2 = 50
    y1 = -50
    y2 = 50
    z1 = 0
    z2 = 50

    # Path and Trajectory plotting
    Articulated.plot(traj1.q,limits=[x1, x2, y1, y2, z1, z2])
    Articulated.plot(traj2.q,limits=[x1, x2, y1, y2, z1, z2])
    Articulated.plot(traj3.q,limits=[x1, x2, y1, y2, z1, z2])
    Articulated.plot(traj4.q,limits=[x1, x2, y1, y2, z1, z2])
    Articulated.plot(traj5.q,limits=[x1, x2, y1, y2, z1, z2])
    Articulated.plot(traj6.q,limits=[x1, x2, y1, y2, z1, z2])
    Articulated.plot(traj7.q,limits=[x1, x2, y1, y2, z1, z2])
    Articulated.plot(traj8.q,limits=[x1, x2, y1, y2, z1, z2])
    Articulated.plot(traj9.q,limits=[x1, x2, y1, y2, z1, z2])
    Articulated.plot(traj10.q,limits=[x1, x2, y1, y2, z1, z2])
    Articulated.plot(traj11.q,limits=[x1, x2, y1, y2, z1, z2])
    Articulated.plot(traj12.q,limits=[x1, x2, y1, y2, z1, z2])
    Articulated.plot(traj13.q,limits=[x1, x2, y1, y2, z1, z2])
    Articulated.plot(traj14.q,limits=[x1, x2, y1, y2, z1, z2])
    Articulated.plot(traj15.q,limits=[x1, x2, y1, y2, z1, z2])
    Articulated.plot(traj16.q,limits=[x1, x2, y1, y2, z1, z2])
    Articulated.plot(traj17.q,limits=[x1, x2, y1, y2, z1, z2])
    Articulated.plot(traj18.q,limits=[x1, x2, y1, y2, z1, z2], block=True)


FI = LabelFrame(gui, text="Link Lengths and Joint Variables", font=new_font, bd=0)

FI.grid(row=0, column=0, padx=10, pady=10, sticky=N+W)

a1 = Label(FI, text="a1 =",font=(10))
a1_E = Entry(FI,width=5,font=(10))
cm1 = Label(FI,text=("cm"),font=(10))

a2 = Label(FI,text=("a2 = "),font=(10))
a2_E = Entry(FI,width=5,font=(10))
cm2 = Label(FI,text=("cm"),font=(10))

a3 = Label(FI,text=("a3 = "),font=(10))
a3_E = Entry(FI,width=5,font=(10))
cm3 = Label(FI,text=("cm"),font=(10))

a1.grid(row=0,column=0)
a1_E.grid(row=0,column=1)
cm1.grid(row=0,column=2)

a2.grid(row=1,column=0)
a2_E.grid(row=1,column=1)
cm2.grid(row=1,column=2)

a3.grid(row=2,column=0)
a3_E.grid(row=2,column=1)
cm3.grid(row=2,column=2)

T1 = Label(FI, text="th1 =",font=(10))
T1_E = Entry(FI,width=5,font=(10))
deg1 = Label(FI,text=("deg"),font=(10))

T2 = Label(FI, text="th2 =",font=(10))
T2_E = Entry(FI,width=5,font=(10))
deg2 = Label(FI,text=("deg"),font=(10))

T3 = Label(FI, text="th3 =",font=(10))
T3_E = Entry(FI,width=5,font=(10))
deg3 = Label(FI,text=("deg"),font=(10))

T1.grid(row=0,column=3)
T1_E.grid(row=0,column=4)
deg1.grid(row=0,column=5)

T2.grid(row=1,column=3)
T2_E.grid(row=1,column=4)
deg2.grid(row=1,column=5)

T3.grid(row=2,column=3)
T3_E.grid(row=2,column=4)
deg3.grid(row=2,column=5)

BF = LabelFrame(gui,text="    Forward & Inverse Kinematics    ",font=new_font, bd=0)
BF.grid(row=1, column=0, padx=10, pady=10, sticky=NW,)

FK = Button(BF,text="Forward",font=(10),bg="black",fg="pink", command = f_k)
rst= Button(BF,text="Reset",font=(10),bg="green",fg="blue", command = reset)
IK = Button(BF,text="Inverse",font=(10),bg="yellow",fg="red", command = i_k)

FK.grid(row=0,column=0,columnspan=2,padx=10, pady=10)
rst.grid(row=0,column=2,padx=10,pady=10)
IK.grid(row=0,column=3,padx=10,pady=10)

PV = LabelFrame(gui,text="Position Vectors",font=new_font, bd=0)
PV.grid(row=2,column=0)

X = Label(PV,text=("X = "),font=(10))
X_E = Entry(PV,width=5,font=(10))
cm4 = Label(PV,text=("cm"),font=(10))

Y = Label(PV,text=("Y = "),font=(10))
Y_E = Entry(PV,width=5,font=(10))
cm5 = Label(PV,text=("cm"),font=(10))

Z = Label(PV,text=("Z = "),font=(10))
Z_E = Entry(PV,width=5,font=(10))
cm6 = Label(PV,text=("cm"),font=(10))

X.grid(row=0,column=0)
X_E.grid(row=0,column=1)
cm4.grid(row=0,column=2)

Y.grid(row=1,column=0)
Y_E.grid(row=1,column=1)
cm5.grid(row=1,column=2)

Z.grid(row=2,column=0)
Z_E.grid(row=2,column=1)
cm6.grid(row=2,column=2)


PT = LabelFrame(gui,text="Path and Trajectory Planning",font=(20))
PT.grid(row=4,column=0)

PT_B = Button(PT,text="Path and Trajectory",font=(10),bg="black", fg="white",command=pt)
PT_B.grid(row=0,column=0)

gui.mainloop()
![24](https://github.com/icecreamperson/Robotics2_JacobianandPT_Group8_ArticulatedManipulator_2024/assets/157493649/218da746-3142-4e20-a5bd-589e0b5b4b50)
